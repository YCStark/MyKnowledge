

<!DOCTYPE html>
<html lang="">
<head prefix="og: http://ogp.me/ns#">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
    <meta name="description" content="">
    <title>Hexo</title>

    <!-- Open Graph -->
    <meta name="description" content="#一、基本 ##1. JSX 特性：  可以生成React元素，便于阅读，JSX分割成多行时，推荐使用JSX包裹起来，可避免分号自动插入的陷阱。 “” —指定字符串字面量 {} 和“” 不能同时作用同一属性（引号包裹大括号） 空标签，应跟XML一样 要闭合它。 JSX防止注入攻击—-嵌入用户输入是安全的。   默认情况下， 在渲染之前, React DOM 会格式化(escapes) JSX中的所">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/2018/05/10/React 学习/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="#一、基本 ##1. JSX 特性：  可以生成React元素，便于阅读，JSX分割成多行时，推荐使用JSX包裹起来，可避免分号自动插入的陷阱。 “” —指定字符串字面量 {} 和“” 不能同时作用同一属性（引号包裹大括号） 空标签，应跟XML一样 要闭合它。 JSX防止注入攻击—-嵌入用户输入是安全的。   默认情况下， 在渲染之前, React DOM 会格式化(escapes) JSX中的所">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-04-04T09:22:23.864Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="#一、基本 ##1. JSX 特性：  可以生成React元素，便于阅读，JSX分割成多行时，推荐使用JSX包裹起来，可避免分号自动插入的陷阱。 “” —指定字符串字面量 {} 和“” 不能同时作用同一属性（引号包裹大括号） 空标签，应跟XML一样 要闭合它。 JSX防止注入攻击—-嵌入用户输入是安全的。   默认情况下， 在渲染之前, React DOM 会格式化(escapes) JSX中的所">

    <script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Person",
  "email": "mailto:",
  "image": "",
  "name": "John Doe",
  "url": "http://yoursite.com"
}
</script>
    <script>
    var algoliaEnabled = false;
    
</script>

    

    
    
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
    
    
    
        <!-- stylesheets list from config.yml -->
        
        <link rel="stylesheet" href="/css/aloha.css">
        
        <link rel="stylesheet" href="//cdn.bootcss.com/semantic-ui/2.2.4/semantic.min.css">
        
        <link rel="stylesheet" href="//cdn.bootcss.com/magnific-popup.js/1.1.0/magnific-popup.min.css">
        
    

</head>
<body id="body" style="margin-bottom: 0;" class="pushable">

    <div class="ui top fixed menu">
        <a class="item" id="menu-icon"><i class="sidebar icon"></i></a>
    </div>

    <div id="menu-sidebar" class="ui left vertical sidebar menu">

    <div id="sidebar-top">
        <div class="content">
            <h3>Hexo</h3>
        </div>
    </div>
    <div class="ui container sidebar-card">
    <div class="ui people shape content">
        <div class="active side">
            <div class="ui card">
                <div class="image">
                    <img class="ui medium bordered image" src="/images/avatar.jpg">
                </div>
                <div class="content">
                    <a class="header">John Doe</a>
                    
                </div>
                <div class="extra content">
                    <div class="ui list">
                        
                        
                    </div>

                </div>
                <div class="extra content">
                    <div class="ui list">
                        
                    </div>
                </div>
            </div>
        </div>
    </div>


</div>

    
    

    

    
    <a href="/index.html" class="item" >
        <i class="home icon"></i>
        HOME
    </a>

    

    
</div>

    <div class="pusher body-content">
        <div id="content" class="ui main container">
            <!--<div class="ui one column grid">-->
                <!--<div class="column">-->
                    <!--<div class="ui main container">-->
                        <div id="post-React 学习" class="ui main container article-type-post">

    

    <div class="ui divided grid">

        <div class="two column row" id="article-content">

            <div class="thirteen wide computer thirteen wide tablet sixteen wide mobile column">
                

                <div class="article-inner">

                    <div class="article-entry" itemprop="articleBody">
                        
                        <p>#一、基本</p>
<p>##1. JSX</p>
<p>特性：</p>
<ul>
<li>可以生成React元素，便于阅读，JSX分割成多行时，推荐使用JSX包裹起来，可避免分号自动插入的陷阱。</li>
<li>“” —指定字符串字面量</li>
<li>{} 和“” 不能同时作用同一属性（引号包裹大括号）</li>
<li>空标签，应跟XML一样 要闭合它。</li>
<li>JSX防止注入攻击—-嵌入用户输入是安全的。</li>
</ul>
<blockquote>
<p>默认情况下， 在渲染之前, React DOM 会格式化(<a href="http://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html" target="_blank" rel="noopener">escapes</a>) JSX中的所有值. 从而保证用户无法注入任何应用之外的代码. 在被渲染之前，所有的数据都被转义成为了字符串处理。 以避免 <a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="noopener">XSS(跨站脚本)</a> 攻击。</p>
</blockquote>
<p>​      Babel将JSX编译成React.createElement()调用，写成</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = React.createElememt( ‘h1’， props：&#123; <span class="attr">className</span>: ‘greeting’, <span class="attr">children</span>: ‘Hello world’&#125;);</span><br></pre></td></tr></table></figure>
<p>​    称为React元素，可以想象成屏幕上显示内容的一种描述。React会读取这些对象，构建DOM，并保持不断更新。</p>
<p>高级用法：</p>
<p>​      可以用点语法 MyComponents.DatePicker</p>
<p>​      大写才会被编译成React.createElement(EleJSX)</p>
<p>​      不能使用一个普通的表达式作为React数据类型，如需，要将其赋值给大写的变量</p>
<p>If/for不能在JSX中直接使用</p>
<p>没给prop传值，默认true</p>
<p>有个一object类型的props， 可以使用…扩展操作符。</p>
<p>Booleans/Null/ Undefined被忽略</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; &lt;div&gt;&#123;arr.length&amp;&amp; &lt;div /&gt; &lt;/div&gt;&#125; </span><br><span class="line"><span class="comment">//length会被打印，不是Boolean值</span></span><br></pre></td></tr></table></figure>
<p>#2.    元素渲染</p>
<p>​    元素是React应用最小的构建部件（<strong>构建快building blocks</strong>）。原生元素以小写字母开头，而自定义的React类名以大写字母开头，此外组件类只能包含一个顶层标签，否则会报错。添加属性时，class属性写成className，for属性写成htmlFor，因为两者是JS的保留字。</p>
<pre><code>React元素是**不可突变（immutable）元素**，就像电影里的一帧：表示某一特定时间点的UI。更新UI唯一方法是创建一个新元素。

 只需要更新必须更新的部分：将与之与之前的版本逐一对比，只对有必要更新的DOM进行更新
</code></pre><p>#3.组件和属性Components Props（只读）</p>
<p>组件就像JS函数，可以接收任意输入（称为props），并返回React元素，用以描述屏幕显示内容。</p>
<p>   函数式组件（如上）Functional和类组件</p>
<p>   React遇到代表用户定义组件的元素时，以JSX属性以一个单独对象形式传递给相应组件，称为props对象。</p>
<p>（纯函数：对于同样的输入，始终得到相同的结果—–不试图改变输入）</p>
<p>#4.State（状态）</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="title">extendsReact</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">   render() &#123;</span><br><span class="line">       <span class="keyword">return</span> (</span><br><span class="line">       		&lt;div&gt;</span><br><span class="line">               &lt;h1&gt;Helloworld!&lt;/h1&gt;</span><br><span class="line">               &lt;h2&gt;It is &#123;<span class="keyword">this</span>.props.date.toLocalTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">           &lt;/</span>div&gt;;</span><br><span class="line">    ) </span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>类允许添加本地状态state和生命周期钩子。</p>
<p>A．   替换render中的props为state</p>
<p>B．   添加类构造函数（class constructor）初始化this.state</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Constructor（props）&#123;</span><br><span class="line">	Super(props); <span class="keyword">this</span>.state = &#123;<span class="attr">stae</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   添加生命周期（组件销毁释放占用资源是非常重要的）</p>
<p>Clock第一次渲染到DOM时，React中称为“挂载mounting”；DOM销毁时，称为“卸载unmounting”。</p>
<p><code>componentDidMount(){}(组件渲染DOM后)</code></p>
<p><code>componentWillUnmount(){}（）</code></p>
<p>​    把组件看成状态机（State Machines），只需要更新组件State，根据新的State更新渲染用户界面（不要操作DOM）。</p>
<pre><code>`getInitialState`定义初始化状态，也是一个对象；可用过`this.State`读取；`this.setState`修改状态值，每次修改后自动调用`this.render()`,再次渲染。
</code></pre><p><code>This.setState()</code>更新组件本地状态 <code>this.setState({ date: new date() })</code>; 但是不要直接修改state状态，这样不会触发render；<strong>可能是异步的，不能依赖他们的值计算下一个state状态。</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState,props</span>) =&gt;</span> &#123;<span class="attr">date</span>: prevState.date+<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>
<pre><code>**State** **更新会被合并。调用setState()，将合并你提供的对象到当前状态中，浅合并。**
</code></pre><p>State可以向子组件传递（向下传递），作为子组件的props，<strong>举例</strong></p>
<p>#5.事件</p>
<p>驼峰法camal，</p>
<p>​    不能通过返回false阻止默认行为。 必须明确调用event.preventDefault()</p>
<pre><code>**JSX****中注意this的指向，JS中类方法默认没有绑定**。constuctor中：This.handleClick=this.handleClick.bind(this)，或者 类组件中直接对该函数赋值：handleClick = () =&gt; {} （**属性初始化语法**）
</code></pre><p>​    或者 直接把函数写在JSX中。（渲染时创建不同的回调，<strong>作为prop传递时，可能需要额外的渲染</strong>）</p>
<p>#6.条件渲染</p>
<p>​    <strong>元素变量：</strong>可用变量存储原始，可以有条件的渲染组件一部分，输出其余部分不会更改</p>
<pre><code>除了if外，可以在JSX中用&amp;&amp;，三目运算符？：

 **阻止组件渲染**：以往隐藏时，可render返回null，不影响组件生命周期方法的触发。
</code></pre><p>#7.列表Lists和键Keys</p>
<p>Map函数 返回 JSX格式</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> numbers = props.numbers.map(<span class="function">(<span class="params">num</span>) =&gt;</span> &lt;li</span><br><span class="line">key=&#123;num.toString()&#125;&gt;&#123;num&#125;&lt;<span class="regexp">/li&gt;);</span></span><br><span class="line"><span class="regexp">	return(&lt;ul&gt;&#123;numbers&#125;&lt;/u</span>l&gt;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建元素列表时，key是一个你需要包含的特殊字符串属性。</span></span><br></pre></td></tr></table></figure>
<p>   键是React的内部映射，但其不会传递给组件内部，如需使用需要另外申明。（<strong>数组展示才需要key？</strong>）</p>
<p>#8.表单Forms</p>
<p>受控组件controlled components的技术</p>
<p>通过React的state成为单一数据源原则来结合这两种形式，组件可以控制用户输入之后的行为（其值由React控制的输入表单元素称为受控组件）</p>
<p>   Input/select/textarea 通过value属性控制；select可以传递数组给value，选择多个选项</p>
<p>#9.状态提升Lifting State Up</p>
<p>一个数据变化需要不同的组件来反映·，建议提升共享的状态到最近的祖先组件中</p>
<p>#10.组合 vs 继承 composition inheritance</p>
<p><strong>如果非要在组件中重用非</strong> <strong>UI</strong> <strong>功能，建议将其单独提取到</strong> <strong>JS</strong> <strong>模块中，组件可以导入它并使用该函数，对象或类，而不是扩展它。</strong></p>
<p>##11.编程思想</p>
<p>是否是state：</p>
<p>A. 是否通过props从父级传入；B. 是否永远不变化；C. 是否有组件其他state或props计算出。</p>
<p><strong>反向数据流</strong></p>
<p>通过事件触发父类setState().</p>
<p>#二、高级</p>
<p>##1.    PropTypes类型检查</p>
<p>Reactv15.5，React.PropTypes已被弃用，建议prop-types库定义contextTypes。</p>
<p>​      Import PropTypes from‘prop-types’;</p>
<p>​      Class Greeting extendsReact.Component {</p>
<p>​           Render() { return<div>{this.props.name}</div>}</p>
<p>}</p>
<p>​      Greeting.propTypes = {</p>
<p>​      Name: PropTypes.string</p>
<p>};</p>
<p>控制台警告，性能原因，仅在开发模式检测。</p>
<p>##2.    Flow 类型检测</p>
<p>##3. Refs 和 DOM</p>
<p>使用场景：处理focus 文本选择或媒体播放；触发强制动画；集成第三方DOM库。</p>
<p>如果可以通过申明实现，尽量避免使用refs</p>
<p>##8. 一致性比较Reconciliation</p>
<p>​      </p>
<p>##9. 上下文（Context）</p>
<p>​      想在整个组件树中传递数据，却不想手动地在每一层传递属性</p>
<p>缺点：实验性API，可能移除。</p>
<p>子类：Button组件：Button.contextTypes = { color：PropTypes.string  }</p>
<p>父类：Message组件：getChildContext（）{ return { color：‘purple’}}</p>
<p>​       Message.childContextTypes = { color: PropTypes.string}</p>
<p>React自动向下传递信息，子树中任何组件，都可以通过定义contextTypes访问他（this.context.color），如果无定义，context为空对象</p>
<p>​       生命周期方法可以用context</p>
<p>Constructor（props, context）</p>
<p>componentWillReceiveProps(nextProps, nextContext )</p>
<p>shouldComponentUpdate(nextProps, nextState, nextContext )</p>
<p>componentWillUpdate(nextProps, nextState, nextContext )</p>
<p>componentDidUpdate(prevProps, prevState, prevContext )——–React16，不再接收prevContext。</p>
<p>​       更新Context</p>
<p>​       getChildContext 在每次state、props改变时调用。为更新context，this.setState触发本地状态更新</p>
<p>​       getChildContext() { return { type:this.state.type }}</p>
<p><strong>组件提供**</strong>context<strong><strong>改变，后代元素</strong></strong>shouldComponentUpdate<strong><strong>返回</strong></strong>false<strong><strong>，</strong></strong>context<strong>**将不会更新。</strong></p>
<p>##10．片段Fragment</p>
<p>​       让你将子元素列表添加到一个分组红，不在DOM增加额外节点</p>
<p>（必须为JSX加上父元素，可能造成样式不协调）</p>
<p>例：table的行tr</p>
<p>​       Class Columns extends Component {</p>
<p>​       Render() {</p>
<p>​       Return<div><td>Hello</td><td>world</td></div></p>
<p>}</p>
<p>}</p>
<p>可换成</p>
<p>​       Return (&lt;React.Fragment&gt;</p>
<p>​                           <td>hello</td></p>
<td>world</td>

<p>&lt;/React.Frament&gt;)</p>
<p>解析后，不增加React.Fragment节点</p>
<p>简写：&lt;&gt;  &lt;/&gt;（不支持键keys或属性attributes，很多工具不支持）</p>
<p>​       带key的片段：数组展示</p>
<p>##11. 插槽（Portals）</p>
<p>将子节点渲染到DOM结构层次之外</p>
<p>ReactDOM.createProtal（child, container）</p>
<p>Child: 任何可渲染子元素； container：DOM元素</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">render() &#123; </span><br><span class="line">       <span class="keyword">return</span> ReactDOM.createPortal (</span><br><span class="line">           <span class="keyword">this</span>.props.children, domNode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经典用例：父组件有overflow：hidden或z-index样式，需要子组件在视觉上跳出（break out）其容器</p>
<p>​       <strong>通过</strong> <strong>Portals</strong> <strong>进行事件冒泡</strong></p>

                        
                    </div>

                    
                    
                    

                    <div class="description post-description">
    <span class="post-description-item">
        <time datetime="2018-05-10T07:09:04.742Z" itemprop="datePublished">2018-05-10</time>

    </span>
    <span class="post-description-item">
        
    </span>
</div>

                </div>
                
                <div id="pagination" class="nav-web ui text container pagination">

    <div class="ui stackable two column divided grid container">
        <div class="row">
            <div class="column nav-left">
                

                <a href="/2018/05/10/React-Bootstrap学习/" class="ui tiny button">

                    <i class="angle left icon"></i>
                    
                    (No Title)
                    

                </a>

                
            </div>
            <div class="column nav-right">
                

                <a href="/2018/05/10/Immutable In React/" class="ui tiny button">
                    
                    (No Title)
                    
                    <i class="angle right icon"></i></a>
                
            </div>
        </div>
    </div>

</div>
                
            </div>

            
            <div class="three wide computer three wide tablet column">

                <div class="ui sticky article-toc" id="article-toc">
                    <!-- toc -->
                    
                </div>

            </div>
            

        </div>
    </div>
</div>


                    <!--</div>-->
                <!--</div>-->
            <!--</div>-->
        </div>
        <div class="ui vertical footer segment">
    <div class="ui center aligned container">
        <div class="ui inverted section divider"></div>
        &copy; 2018 <a href="/">John Doe</a>,
        Powered by <a href="https://github.com/henryhuang/hexo-theme-aloha" target="_blank">Aloha</a> and <a
                href="http://hexo.io/" target="_blank">Hexo</a>.
    </div>
</div>

    </div>




<!-- scripts list from theme config.yml -->

<script src="//cdn.bootcss.com/jquery/3.1.0/jquery.min.js"></script>

<script src="//cdn.bootcss.com/semantic-ui/2.2.4/semantic.min.js"></script>

<script src="//cdn.bootcss.com/algoliasearch/3.18.1/algoliasearch.min.js"></script>

<script src="//cdn.bootcss.com/algoliasearch-helper-js/2.13.0/algoliasearch.helper.min.js"></script>

<script src="/js/semantic-ui-algolia.js"></script>

<script src="/js/aloha-events.js"></script>



</body>
</html>
